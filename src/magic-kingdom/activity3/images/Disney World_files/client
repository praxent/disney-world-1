import '/node_modules/vite/dist/client/env.mjs';
const template =
/*html*/
`
<style>
:host {
  position: fixed;
  z-index: 99999;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow-y: scroll;
  margin: 0;
  background: rgba(0, 0, 0, 0.66);
  --monospace: 'SFMono-Regular', Consolas,
              'Liberation Mono', Menlo, Courier, monospace;
  --red: #ff5555;
  --yellow: #e2aa53;
  --purple: #cfa4ff;
  --cyan: #2dd9da;
  --dim: #c9c9c9;
}

.window {
  font-family: var(--monospace);
  line-height: 1.5;
  width: 800px;
  color: #d8d8d8;
  margin: 30px auto;
  padding: 25px 40px;
  position: relative;
  background: #181818;
  border-radius: 6px 6px 8px 8px;
  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);
  overflow: hidden;
  border-top: 8px solid var(--red);
  direction: ltr;
  text-align: left;
}

pre {
  font-family: var(--monospace);
  font-size: 16px;
  margin-top: 0;
  margin-bottom: 1em;
  overflow-x: scroll;
  scrollbar-width: none;
}

pre::-webkit-scrollbar {
  display: none;
}

.message {
  line-height: 1.3;
  font-weight: 600;
  white-space: pre-wrap;
}

.message-body {
  color: var(--red);
}

.plugin {
  color: var(--purple);
}

.file {
  color: var(--cyan);
  margin-bottom: 0;
  white-space: pre-wrap;
  word-break: break-all;
}

.frame {
  color: var(--yellow);
}

.stack {
  font-size: 13px;
  color: var(--dim);
}

.tip {
  font-size: 13px;
  color: #999;
  border-top: 1px dotted #999;
  padding-top: 13px;
}

code {
  font-size: 13px;
  font-family: var(--monospace);
  color: var(--yellow);
}

.file-link {
  text-decoration: underline;
  cursor: pointer;
}
</style>
<div class="window">
  <pre class="message"><span class="plugin"></span><span class="message-body"></span></pre>
  <pre class="file"></pre>
  <pre class="frame"></pre>
  <pre class="stack"></pre>
  <div class="tip">
    Click outside or fix the code to dismiss.<br>
    You can also disable this overlay by setting
    <code>server.hmr.overlay</code> to <code>false</code> in <code>vite.config.js.</code>
  </div>
</div>
`;
const fileRE = /(?:[a-zA-Z]:\\|\/).*?:\d+:\d+/g;
const codeframeRE = /^(?:>?\s+\d+\s+\|.*|\s+\|\s*\^.*)\r?\n/gm;

class ErrorOverlay extends HTMLElement {
  constructor(err) {
    var _a;

    super();
    this.root = this.attachShadow({
      mode: 'open'
    });
    this.root.innerHTML = template;
    codeframeRE.lastIndex = 0;
    const hasFrame = err.frame && codeframeRE.test(err.frame);
    const message = hasFrame ? err.message.replace(codeframeRE, '') : err.message;

    if (err.plugin) {
      this.text('.plugin', `[plugin:${err.plugin}] `);
    }

    this.text('.message-body', message.trim());
    const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);

    if (err.loc) {
      this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, true);
    } else if (err.id) {
      this.text('.file', file);
    }

    if (hasFrame) {
      this.text('.frame', err.frame.trim());
    }

    this.text('.stack', err.stack, true);
    this.root.querySelector('.window').addEventListener('click', e => {
      e.stopPropagation();
    });
    this.addEventListener('click', () => {
      this.close();
    });
  }

  text(selector, text, linkFiles = false) {
    const el = this.root.querySelector(selector);

    if (!linkFiles) {
      el.textContent = text;
    } else {
      let curIndex = 0;
      let match;

      while (match = fileRE.exec(text)) {
        const {
          0: file,
          index
        } = match;

        if (index != null) {
          const frag = text.slice(curIndex, index);
          el.appendChild(document.createTextNode(frag));
          const link = document.createElement('a');
          link.textContent = file;
          link.className = 'file-link';

          link.onclick = () => {
            fetch('/__open-in-editor?file=' + encodeURIComponent(file));
          };

          el.appendChild(link);
          curIndex += frag.length + file.length;
        }
      }
    }
  }

  close() {
    var _a;

    (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);
  }

}

const overlayId = 'vite-error-overlay';

if (customElements && !customElements.get(overlayId)) {
  customElements.define(overlayId, ErrorOverlay);
}

console.log('[vite] connecting...'); // use server configuration, then fallback to inference

const socketProtocol = null || (location.protocol === 'https:' ? 'wss' : 'ws');
const socketHost = `${null || location.hostname}:${"3000"}`;
const socket = new WebSocket(`${socketProtocol}://${socketHost}`, 'vite-hmr');
const base = "/" || '/';

function warnFailedFetch(err, path) {
  if (!err.message.match('fetch')) {
    console.error(err);
  }

  console.error(`[hmr] Failed to reload ${path}. ` + `This could be due to syntax errors or importing non-existent ` + `modules. (see errors above)`);
} // Listen for messages


socket.addEventListener('message', async ({
  data
}) => {
  handleMessage(JSON.parse(data));
});
let isFirstUpdate = true;

async function handleMessage(payload) {
  switch (payload.type) {
    case 'connected':
      console.log(`[vite] connected.`); // proxy(nginx, docker) hmr ws maybe caused timeout,
      // so send ping package let ws keep alive.

      setInterval(() => socket.send('ping'), 30000);
      break;

    case 'update':
      notifyListeners('vite:beforeUpdate', payload); // if this is the first update and there's already an error overlay, it
      // means the page opened with existing server compile error and the whole
      // module script failed to load (since one of the nested imports is 500).
      // in this case a normal update won't work and a full reload is needed.

      if (isFirstUpdate && hasErrorOverlay()) {
        window.location.reload();
        return;
      } else {
        clearErrorOverlay();
        isFirstUpdate = false;
      }

      payload.updates.forEach(update => {
        if (update.type === 'js-update') {
          queueUpdate(fetchUpdate(update));
        } else {
          // css-update
          // this is only sent when a css file referenced with <link> is updated
          let {
            path,
            timestamp
          } = update;
          path = path.replace(/\?.*/, ''); // can't use querySelector with `[href*=]` here since the link may be
          // using relative paths so we need to use link.href to grab the full
          // URL for the include check.

          const el = [].slice.call(document.querySelectorAll(`link`)).find(e => e.href.includes(path));

          if (el) {
            const newPath = `${base}${path.slice(1)}${path.includes('?') ? '&' : '?'}t=${timestamp}`;
            el.href = new URL(newPath, el.href).href;
          }

          console.log(`[vite] css hot updated: ${path}`);
        }
      });
      break;

    case 'custom':
      {
        notifyListeners(payload.event, payload.data);
        break;
      }

    case 'full-reload':
      notifyListeners('vite:beforeFullReload', payload);

      if (payload.path && payload.path.endsWith('.html')) {
        // if html file is edited, only reload the page if the browser is
        // currently on that page.
        const pagePath = location.pathname;
        const payloadPath = base + payload.path.slice(1);

        if (pagePath === payloadPath || pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath) {
          location.reload();
        }

        return;
      } else {
        location.reload();
      }

      break;

    case 'prune':
      notifyListeners('vite:beforePrune', payload); // After an HMR update, some modules are no longer imported on the page
      // but they may have left behind side effects that need to be cleaned up
      // (.e.g style injections)
      // TODO Trigger their dispose callbacks.

      payload.paths.forEach(path => {
        const fn = pruneMap.get(path);

        if (fn) {
          fn(dataMap.get(path));
        }
      });
      break;

    case 'error':
      {
        notifyListeners('vite:error', payload);
        const err = payload.err;

        if (enableOverlay) {
          createErrorOverlay(err);
        } else {
          console.error(`[vite] Internal Server Error\n${err.message}\n${err.stack}`);
        }

        break;
      }

    default:
      {
        const check = payload;
        return check;
      }
  }
}

function notifyListeners(event, data) {
  const cbs = customListenersMap.get(event);

  if (cbs) {
    cbs.forEach(cb => cb(data));
  }
}

const enableOverlay = true;

function createErrorOverlay(err) {
  if (!enableOverlay) return;
  clearErrorOverlay();
  document.body.appendChild(new ErrorOverlay(err));
}

function clearErrorOverlay() {
  document.querySelectorAll(overlayId).forEach(n => n.close());
}

function hasErrorOverlay() {
  return document.querySelectorAll(overlayId).length;
}

let pending = false;
let queued = [];
/**
 * buffer multiple hot updates triggered by the same src change
 * so that they are invoked in the same order they were sent.
 * (otherwise the order may be inconsistent because of the http request round trip)
 */

async function queueUpdate(p) {
  queued.push(p);

  if (!pending) {
    pending = true;
    await Promise.resolve();
    pending = false;
    const loading = [...queued];
    queued = [];
    (await Promise.all(loading)).forEach(fn => fn && fn());
  }
}

async function waitForSuccessfulPing(ms = 1000) {
  // eslint-disable-next-line no-constant-condition
  while (true) {
    try {
      await fetch(`${base}__vite_ping`);
      break;
    } catch (e) {
      await new Promise(resolve => setTimeout(resolve, ms));
    }
  }
} // ping server


socket.addEventListener('close', async ({
  wasClean
}) => {
  if (wasClean) return;
  console.log(`[vite] server connection lost. polling for restart...`);
  await waitForSuccessfulPing();
  location.reload();
});
const sheetsMap = new Map();

function updateStyle(id, content) {
  let style = sheetsMap.get(id);
  {
    if (style && !(style instanceof HTMLStyleElement)) {
      removeStyle(id);
      style = undefined;
    }

    if (!style) {
      style = document.createElement('style');
      style.setAttribute('type', 'text/css');
      style.innerHTML = content;
      document.head.appendChild(style);
    } else {
      style.innerHTML = content;
    }
  }
  sheetsMap.set(id, style);
}

function removeStyle(id) {
  const style = sheetsMap.get(id);

  if (style) {
    if (style instanceof CSSStyleSheet) {
      // @ts-ignore
      document.adoptedStyleSheets.indexOf(style); // @ts-ignore

      document.adoptedStyleSheets = document.adoptedStyleSheets.filter(s => s !== style);
    } else {
      document.head.removeChild(style);
    }

    sheetsMap.delete(id);
  }
}

async function fetchUpdate({
  path,
  acceptedPath,
  timestamp
}) {
  const mod = hotModulesMap.get(path);

  if (!mod) {
    // In a code-splitting project,
    // it is common that the hot-updating module is not loaded yet.
    // https://github.com/vitejs/vite/issues/721
    return;
  }

  const moduleMap = new Map();
  const isSelfUpdate = path === acceptedPath; // make sure we only import each dep once

  const modulesToUpdate = new Set();

  if (isSelfUpdate) {
    // self update - only update self
    modulesToUpdate.add(path);
  } else {
    // dep update
    for (const {
      deps
    } of mod.callbacks) {
      deps.forEach(dep => {
        if (acceptedPath === dep) {
          modulesToUpdate.add(dep);
        }
      });
    }
  } // determine the qualified callbacks before we re-import the modules


  const qualifiedCallbacks = mod.callbacks.filter(({
    deps
  }) => {
    return deps.some(dep => modulesToUpdate.has(dep));
  });
  await Promise.all(Array.from(modulesToUpdate).map(async dep => {
    const disposer = disposeMap.get(dep);
    if (disposer) await disposer(dataMap.get(dep));
    const [path, query] = dep.split(`?`);

    try {
      const newMod = await import(
      /* @vite-ignore */
      base + path.slice(1) + `?import&t=${timestamp}${query ? `&${query}` : ''}`);
      moduleMap.set(dep, newMod);
    } catch (e) {
      warnFailedFetch(e, dep);
    }
  }));
  return () => {
    for (const {
      deps,
      fn
    } of qualifiedCallbacks) {
      fn(deps.map(dep => moduleMap.get(dep)));
    }

    const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;
    console.log(`[vite] hot updated: ${loggedPath}`);
  };
}

const hotModulesMap = new Map();
const disposeMap = new Map();
const pruneMap = new Map();
const dataMap = new Map();
const customListenersMap = new Map();
const ctxToListenersMap = new Map(); // Just infer the return type for now
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

const createHotContext = ownerPath => {
  if (!dataMap.has(ownerPath)) {
    dataMap.set(ownerPath, {});
  } // when a file is hot updated, a new context is created
  // clear its stale callbacks


  const mod = hotModulesMap.get(ownerPath);

  if (mod) {
    mod.callbacks = [];
  } // clear stale custom event listeners


  const staleListeners = ctxToListenersMap.get(ownerPath);

  if (staleListeners) {
    for (const [event, staleFns] of staleListeners) {
      const listeners = customListenersMap.get(event);

      if (listeners) {
        customListenersMap.set(event, listeners.filter(l => !staleFns.includes(l)));
      }
    }
  }

  const newListeners = new Map();
  ctxToListenersMap.set(ownerPath, newListeners);

  function acceptDeps(deps, callback = () => {}) {
    const mod = hotModulesMap.get(ownerPath) || {
      id: ownerPath,
      callbacks: []
    };
    mod.callbacks.push({
      deps,
      fn: callback
    });
    hotModulesMap.set(ownerPath, mod);
  }

  const hot = {
    get data() {
      return dataMap.get(ownerPath);
    },

    accept(deps, callback) {
      if (typeof deps === 'function' || !deps) {
        // self-accept: hot.accept(() => {})
        acceptDeps([ownerPath], ([mod]) => deps && deps(mod));
      } else if (typeof deps === 'string') {
        // explicit deps
        acceptDeps([deps], ([mod]) => callback && callback(mod));
      } else if (Array.isArray(deps)) {
        acceptDeps(deps, callback);
      } else {
        throw new Error(`invalid hot.accept() usage.`);
      }
    },

    acceptDeps() {
      throw new Error(`hot.acceptDeps() is deprecated. ` + `Use hot.accept() with the same signature instead.`);
    },

    dispose(cb) {
      disposeMap.set(ownerPath, cb);
    },

    prune(cb) {
      pruneMap.set(ownerPath, cb);
    },

    // TODO
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    decline() {},

    invalidate() {
      // TODO should tell the server to re-perform hmr propagation
      // from this module as root
      location.reload();
    },

    // custom events
    on: (event, cb) => {
      const addToMap = map => {
        const existing = map.get(event) || [];
        existing.push(cb);
        map.set(event, existing);
      };

      addToMap(customListenersMap);
      addToMap(newListeners);
    }
  };
  return hot;
};
/**
 * urls here are dynamic import() urls that couldn't be statically analyzed
 */


function injectQuery(url, queryToInject) {
  // skip urls that won't be handled by vite
  if (!url.startsWith('.') && !url.startsWith('/')) {
    return url;
  } // can't use pathname from URL since it may be relative like ../


  const pathname = url.replace(/#.*$/, '').replace(/\?.*$/, '');
  const {
    search,
    hash
  } = new URL(url, 'http://vitejs.dev');
  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;
}

export { createHotContext, injectQuery, removeStyle, updateStyle }; //# sourceMappingURL=client.mjs.map
//# sourceMappingURL=data:application/json;base64,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Z0JXLFlBQVlDLEtBQWFDLGVBQXFCOztBQUU1RCxNQUFJLENBQUNELEdBQUcsQ0FBQ0UsVUFBSixDQUFlLEdBQWYsQ0FBRCxJQUF3QixDQUFDRixHQUFHLENBQUNFLFVBQUosQ0FBZSxHQUFmLENBQTdCLEVBQWtEO0FBQ2hELFdBQU9GLEdBQVA7QUFDRCxHQUoyRDs7O0FBTzVELFFBQU14RixRQUFRLEdBQUd3RixHQUFHLENBQUNuTCxPQUFKLENBQVksTUFBWixFQUFvQixFQUFwQixFQUF3QkEsT0FBeEIsQ0FBZ0MsT0FBaEMsRUFBeUMsRUFBekMsQ0FBakI7QUFDQSxRQUFNO0FBQUVzTCxVQUFGO0FBQVVDO0FBQVYsTUFBbUIsSUFBSWhHLEdBQUosQ0FBUTRGLEdBQVIsRUFBYSxtQkFBYixDQUF6QjtBQUVBLFNBQU8sR0FBR3hGLFFBQVEsSUFBSXlGLGFBQWEsR0FBR0UsTUFBTSxHQUFHLE1BQU1BLE1BQU0sQ0FBQzVKLEtBQVAsQ0FBYSxDQUFiLENBQVQsR0FBMkIsRUFBRSxHQUN2RTZKLElBQUksSUFBSSxFQUNWLEVBRkE7QUFHRjs7IiwibmFtZXMiOlsidGVtcGxhdGUiLCJmaWxlUkUiLCJjb2RlZnJhbWVSRSIsIkVycm9yT3ZlcmxheSIsIkhUTUxFbGVtZW50IiwiY29uc3RydWN0b3IiLCJlcnIiLCJyb290IiwiYXR0YWNoU2hhZG93IiwibW9kZSIsImlubmVySFRNTCIsImxhc3RJbmRleCIsImhhc0ZyYW1lIiwiZnJhbWUiLCJ0ZXN0IiwibWVzc2FnZSIsInJlcGxhY2UiLCJwbHVnaW4iLCJ0ZXh0IiwidHJpbSIsImZpbGUiLCJsb2MiLCJfYSIsImlkIiwic3BsaXQiLCJsaW5lIiwiY29sdW1uIiwic3RhY2siLCJxdWVyeVNlbGVjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJjbG9zZSIsInNlbGVjdG9yIiwibGlua0ZpbGVzIiwiZWwiLCJ0ZXh0Q29udGVudCIsImN1ckluZGV4IiwibWF0Y2giLCJleGVjIiwiaW5kZXgiLCJmcmFnIiwic2xpY2UiLCJhcHBlbmRDaGlsZCIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJsaW5rIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsIm9uY2xpY2siLCJmZXRjaCIsImVuY29kZVVSSUNvbXBvbmVudCIsImxlbmd0aCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIm92ZXJsYXlJZCIsImN1c3RvbUVsZW1lbnRzIiwiZ2V0IiwiZGVmaW5lIiwiY29uc29sZSIsImxvZyIsInNvY2tldFByb3RvY29sIiwiX19ITVJfUFJPVE9DT0xfXyIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJzb2NrZXRIb3N0IiwiX19ITVJfSE9TVE5BTUVfXyIsImhvc3RuYW1lIiwiX19ITVJfUE9SVF9fIiwic29ja2V0IiwiV2ViU29ja2V0IiwiYmFzZSIsIl9fQkFTRV9fIiwid2FybkZhaWxlZEZldGNoIiwicGF0aCIsImVycm9yIiwiZGF0YSIsImhhbmRsZU1lc3NhZ2UiLCJKU09OIiwicGFyc2UiLCJpc0ZpcnN0VXBkYXRlIiwicGF5bG9hZCIsInR5cGUiLCJzZXRJbnRlcnZhbCIsInNlbmQiLCJfX0hNUl9USU1FT1VUX18iLCJub3RpZnlMaXN0ZW5lcnMiLCJoYXNFcnJvck92ZXJsYXkiLCJ3aW5kb3ciLCJyZWxvYWQiLCJjbGVhckVycm9yT3ZlcmxheSIsInVwZGF0ZXMiLCJmb3JFYWNoIiwidXBkYXRlIiwicXVldWVVcGRhdGUiLCJmZXRjaFVwZGF0ZSIsInRpbWVzdGFtcCIsImNhbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZmluZCIsImhyZWYiLCJpbmNsdWRlcyIsIm5ld1BhdGgiLCJVUkwiLCJldmVudCIsImVuZHNXaXRoIiwicGFnZVBhdGgiLCJwYXRobmFtZSIsInBheWxvYWRQYXRoIiwicGF0aHMiLCJmbiIsInBydW5lTWFwIiwiZGF0YU1hcCIsImVuYWJsZU92ZXJsYXkiLCJjcmVhdGVFcnJvck92ZXJsYXkiLCJjaGVjayIsImNicyIsImN1c3RvbUxpc3RlbmVyc01hcCIsImNiIiwiX19ITVJfRU5BQkxFX09WRVJMQVlfXyIsImJvZHkiLCJuIiwicGVuZGluZyIsInF1ZXVlZCIsInAiLCJwdXNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkaW5nIiwiYWxsIiwid2FpdEZvclN1Y2Nlc3NmdWxQaW5nIiwibXMiLCJzZXRUaW1lb3V0Iiwid2FzQ2xlYW4iLCJzaGVldHNNYXAiLCJNYXAiLCJ1cGRhdGVTdHlsZSIsImNvbnRlbnQiLCJzdHlsZSIsIkhUTUxTdHlsZUVsZW1lbnQiLCJyZW1vdmVTdHlsZSIsInVuZGVmaW5lZCIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJzZXQiLCJDU1NTdHlsZVNoZWV0IiwiYWRvcHRlZFN0eWxlU2hlZXRzIiwiaW5kZXhPZiIsImZpbHRlciIsInMiLCJkZWxldGUiLCJhY2NlcHRlZFBhdGgiLCJtb2QiLCJob3RNb2R1bGVzTWFwIiwibW9kdWxlTWFwIiwiaXNTZWxmVXBkYXRlIiwibW9kdWxlc1RvVXBkYXRlIiwiU2V0IiwiYWRkIiwiZGVwcyIsImNhbGxiYWNrcyIsImRlcCIsInF1YWxpZmllZENhbGxiYWNrcyIsInNvbWUiLCJoYXMiLCJBcnJheSIsImZyb20iLCJtYXAiLCJkaXNwb3NlciIsImRpc3Bvc2VNYXAiLCJxdWVyeSIsIm5ld01vZCIsImxvZ2dlZFBhdGgiLCJjdHhUb0xpc3RlbmVyc01hcCIsImNyZWF0ZUhvdENvbnRleHQiLCJvd25lclBhdGgiLCJzdGFsZUxpc3RlbmVycyIsInN0YWxlRm5zIiwibGlzdGVuZXJzIiwibCIsIm5ld0xpc3RlbmVycyIsImFjY2VwdERlcHMiLCJjYWxsYmFjayIsImhvdCIsImFjY2VwdCIsImlzQXJyYXkiLCJFcnJvciIsImRpc3Bvc2UiLCJwcnVuZSIsImRlY2xpbmUiLCJpbnZhbGlkYXRlIiwib24iLCJhZGRUb01hcCIsImV4aXN0aW5nIiwiaW5qZWN0UXVlcnkiLCJ1cmwiLCJxdWVyeVRvSW5qZWN0Iiwic3RhcnRzV2l0aCIsInNlYXJjaCIsImhhc2giXSwic291cmNlcyI6WyIuLi8uLi9zcmMvY2xpZW50L292ZXJsYXkudHMiLCIuLi8uLi9zcmMvY2xpZW50L2NsaWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFcnJvclBheWxvYWQgfSBmcm9tICd0eXBlcy9obXJQYXlsb2FkJ1xuXG5jb25zdCB0ZW1wbGF0ZSA9IC8qaHRtbCovIGBcbjxzdHlsZT5cbjpob3N0IHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB6LWluZGV4OiA5OTk5OTtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBvdmVyZmxvdy15OiBzY3JvbGw7XG4gIG1hcmdpbjogMDtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjY2KTtcbiAgLS1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLFxuICAgICAgICAgICAgICAnTGliZXJhdGlvbiBNb25vJywgTWVubG8sIENvdXJpZXIsIG1vbm9zcGFjZTtcbiAgLS1yZWQ6ICNmZjU1NTU7XG4gIC0teWVsbG93OiAjZTJhYTUzO1xuICAtLXB1cnBsZTogI2NmYTRmZjtcbiAgLS1jeWFuOiAjMmRkOWRhO1xuICAtLWRpbTogI2M5YzljOTtcbn1cblxuLndpbmRvdyB7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1tb25vc3BhY2UpO1xuICBsaW5lLWhlaWdodDogMS41O1xuICB3aWR0aDogODAwcHg7XG4gIGNvbG9yOiAjZDhkOGQ4O1xuICBtYXJnaW46IDMwcHggYXV0bztcbiAgcGFkZGluZzogMjVweCA0MHB4O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGJhY2tncm91bmQ6ICMxODE4MTg7XG4gIGJvcmRlci1yYWRpdXM6IDZweCA2cHggOHB4IDhweDtcbiAgYm94LXNoYWRvdzogMCAxOXB4IDM4cHggcmdiYSgwLDAsMCwwLjMwKSwgMCAxNXB4IDEycHggcmdiYSgwLDAsMCwwLjIyKTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgYm9yZGVyLXRvcDogOHB4IHNvbGlkIHZhcigtLXJlZCk7XG4gIGRpcmVjdGlvbjogbHRyO1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xufVxuXG5wcmUge1xuICBmb250LWZhbWlseTogdmFyKC0tbW9ub3NwYWNlKTtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBtYXJnaW4tdG9wOiAwO1xuICBtYXJnaW4tYm90dG9tOiAxZW07XG4gIG92ZXJmbG93LXg6IHNjcm9sbDtcbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xufVxuXG5wcmU6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLm1lc3NhZ2Uge1xuICBsaW5lLWhlaWdodDogMS4zO1xuICBmb250LXdlaWdodDogNjAwO1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbi5tZXNzYWdlLWJvZHkge1xuICBjb2xvcjogdmFyKC0tcmVkKTtcbn1cblxuLnBsdWdpbiB7XG4gIGNvbG9yOiB2YXIoLS1wdXJwbGUpO1xufVxuXG4uZmlsZSB7XG4gIGNvbG9yOiB2YXIoLS1jeWFuKTtcbiAgbWFyZ2luLWJvdHRvbTogMDtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICB3b3JkLWJyZWFrOiBicmVhay1hbGw7XG59XG5cbi5mcmFtZSB7XG4gIGNvbG9yOiB2YXIoLS15ZWxsb3cpO1xufVxuXG4uc3RhY2sge1xuICBmb250LXNpemU6IDEzcHg7XG4gIGNvbG9yOiB2YXIoLS1kaW0pO1xufVxuXG4udGlwIHtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBjb2xvcjogIzk5OTtcbiAgYm9yZGVyLXRvcDogMXB4IGRvdHRlZCAjOTk5O1xuICBwYWRkaW5nLXRvcDogMTNweDtcbn1cblxuY29kZSB7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgZm9udC1mYW1pbHk6IHZhcigtLW1vbm9zcGFjZSk7XG4gIGNvbG9yOiB2YXIoLS15ZWxsb3cpO1xufVxuXG4uZmlsZS1saW5rIHtcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cbjwvc3R5bGU+XG48ZGl2IGNsYXNzPVwid2luZG93XCI+XG4gIDxwcmUgY2xhc3M9XCJtZXNzYWdlXCI+PHNwYW4gY2xhc3M9XCJwbHVnaW5cIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtZXNzYWdlLWJvZHlcIj48L3NwYW4+PC9wcmU+XG4gIDxwcmUgY2xhc3M9XCJmaWxlXCI+PC9wcmU+XG4gIDxwcmUgY2xhc3M9XCJmcmFtZVwiPjwvcHJlPlxuICA8cHJlIGNsYXNzPVwic3RhY2tcIj48L3ByZT5cbiAgPGRpdiBjbGFzcz1cInRpcFwiPlxuICAgIENsaWNrIG91dHNpZGUgb3IgZml4IHRoZSBjb2RlIHRvIGRpc21pc3MuPGJyPlxuICAgIFlvdSBjYW4gYWxzbyBkaXNhYmxlIHRoaXMgb3ZlcmxheSBieSBzZXR0aW5nXG4gICAgPGNvZGU+c2VydmVyLmhtci5vdmVybGF5PC9jb2RlPiB0byA8Y29kZT5mYWxzZTwvY29kZT4gaW4gPGNvZGU+dml0ZS5jb25maWcuanMuPC9jb2RlPlxuICA8L2Rpdj5cbjwvZGl2PlxuYFxuXG5jb25zdCBmaWxlUkUgPSAvKD86W2EtekEtWl06XFxcXHxcXC8pLio/OlxcZCs6XFxkKy9nXG5jb25zdCBjb2RlZnJhbWVSRSA9IC9eKD86Pj9cXHMrXFxkK1xccytcXHwuKnxcXHMrXFx8XFxzKlxcXi4qKVxccj9cXG4vZ21cblxuZXhwb3J0IGNsYXNzIEVycm9yT3ZlcmxheSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgcm9vdDogU2hhZG93Um9vdFxuXG4gIGNvbnN0cnVjdG9yKGVycjogRXJyb3JQYXlsb2FkWydlcnInXSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSB0ZW1wbGF0ZVxuXG4gICAgY29kZWZyYW1lUkUubGFzdEluZGV4ID0gMFxuICAgIGNvbnN0IGhhc0ZyYW1lID0gZXJyLmZyYW1lICYmIGNvZGVmcmFtZVJFLnRlc3QoZXJyLmZyYW1lKVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBoYXNGcmFtZVxuICAgICAgPyBlcnIubWVzc2FnZS5yZXBsYWNlKGNvZGVmcmFtZVJFLCAnJylcbiAgICAgIDogZXJyLm1lc3NhZ2VcbiAgICBpZiAoZXJyLnBsdWdpbikge1xuICAgICAgdGhpcy50ZXh0KCcucGx1Z2luJywgYFtwbHVnaW46JHtlcnIucGx1Z2lufV0gYClcbiAgICB9XG4gICAgdGhpcy50ZXh0KCcubWVzc2FnZS1ib2R5JywgbWVzc2FnZS50cmltKCkpXG5cbiAgICBjb25zdCBbZmlsZV0gPSAoZXJyLmxvYz8uZmlsZSB8fCBlcnIuaWQgfHwgJ3Vua25vd24gZmlsZScpLnNwbGl0KGA/YClcbiAgICBpZiAoZXJyLmxvYykge1xuICAgICAgdGhpcy50ZXh0KCcuZmlsZScsIGAke2ZpbGV9OiR7ZXJyLmxvYy5saW5lfToke2Vyci5sb2MuY29sdW1ufWAsIHRydWUpXG4gICAgfSBlbHNlIGlmIChlcnIuaWQpIHtcbiAgICAgIHRoaXMudGV4dCgnLmZpbGUnLCBmaWxlKVxuICAgIH1cblxuICAgIGlmIChoYXNGcmFtZSkge1xuICAgICAgdGhpcy50ZXh0KCcuZnJhbWUnLCBlcnIuZnJhbWUhLnRyaW0oKSlcbiAgICB9XG4gICAgdGhpcy50ZXh0KCcuc3RhY2snLCBlcnIuc3RhY2ssIHRydWUpXG5cbiAgICB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcignLndpbmRvdycpIS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgfSlcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfSlcbiAgfVxuXG4gIHRleHQoc2VsZWN0b3I6IHN0cmluZywgdGV4dDogc3RyaW5nLCBsaW5rRmlsZXMgPSBmYWxzZSk6IHZvaWQge1xuICAgIGNvbnN0IGVsID0gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIVxuICAgIGlmICghbGlua0ZpbGVzKSB7XG4gICAgICBlbC50ZXh0Q29udGVudCA9IHRleHRcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGN1ckluZGV4ID0gMFxuICAgICAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsXG4gICAgICB3aGlsZSAoKG1hdGNoID0gZmlsZVJFLmV4ZWModGV4dCkpKSB7XG4gICAgICAgIGNvbnN0IHsgMDogZmlsZSwgaW5kZXggfSA9IG1hdGNoXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZnJhZyA9IHRleHQuc2xpY2UoY3VySW5kZXgsIGluZGV4KVxuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGZyYWcpKVxuICAgICAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gZmlsZVxuICAgICAgICAgIGxpbmsuY2xhc3NOYW1lID0gJ2ZpbGUtbGluaydcbiAgICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBmZXRjaCgnL19fb3Blbi1pbi1lZGl0b3I/ZmlsZT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGZpbGUpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChsaW5rKVxuICAgICAgICAgIGN1ckluZGV4ICs9IGZyYWcubGVuZ3RoICsgZmlsZS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIHRoaXMucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodGhpcylcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgb3ZlcmxheUlkID0gJ3ZpdGUtZXJyb3Itb3ZlcmxheSdcbmlmIChjdXN0b21FbGVtZW50cyAmJiAhY3VzdG9tRWxlbWVudHMuZ2V0KG92ZXJsYXlJZCkpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKG92ZXJsYXlJZCwgRXJyb3JPdmVybGF5KVxufVxuIiwiaW1wb3J0IHtcbiAgRXJyb3JQYXlsb2FkLFxuICBGdWxsUmVsb2FkUGF5bG9hZCxcbiAgSE1SUGF5bG9hZCxcbiAgUHJ1bmVQYXlsb2FkLFxuICBVcGRhdGUsXG4gIFVwZGF0ZVBheWxvYWRcbn0gZnJvbSAndHlwZXMvaG1yUGF5bG9hZCdcbmltcG9ydCB7IEN1c3RvbUV2ZW50TmFtZSB9IGZyb20gJ3R5cGVzL2N1c3RvbUV2ZW50J1xuaW1wb3J0IHsgRXJyb3JPdmVybGF5LCBvdmVybGF5SWQgfSBmcm9tICcuL292ZXJsYXknXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby1taXNzaW5nLWltcG9ydFxuaW1wb3J0ICdAdml0ZS9lbnYnXG5cbi8vIGluamVjdGVkIGJ5IHRoZSBobXIgcGx1Z2luIHdoZW4gc2VydmVkXG5kZWNsYXJlIGNvbnN0IF9fQkFTRV9fOiBzdHJpbmdcbmRlY2xhcmUgY29uc3QgX19ITVJfUFJPVE9DT0xfXzogc3RyaW5nXG5kZWNsYXJlIGNvbnN0IF9fSE1SX0hPU1ROQU1FX186IHN0cmluZ1xuZGVjbGFyZSBjb25zdCBfX0hNUl9QT1JUX186IHN0cmluZ1xuZGVjbGFyZSBjb25zdCBfX0hNUl9USU1FT1VUX186IG51bWJlclxuZGVjbGFyZSBjb25zdCBfX0hNUl9FTkFCTEVfT1ZFUkxBWV9fOiBib29sZWFuXG5cbmNvbnNvbGUubG9nKCdbdml0ZV0gY29ubmVjdGluZy4uLicpXG5cbi8vIHVzZSBzZXJ2ZXIgY29uZmlndXJhdGlvbiwgdGhlbiBmYWxsYmFjayB0byBpbmZlcmVuY2VcbmNvbnN0IHNvY2tldFByb3RvY29sID1cbiAgX19ITVJfUFJPVE9DT0xfXyB8fCAobG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ3dzcycgOiAnd3MnKVxuY29uc3Qgc29ja2V0SG9zdCA9IGAke19fSE1SX0hPU1ROQU1FX18gfHwgbG9jYXRpb24uaG9zdG5hbWV9OiR7X19ITVJfUE9SVF9ffWBcbmNvbnN0IHNvY2tldCA9IG5ldyBXZWJTb2NrZXQoYCR7c29ja2V0UHJvdG9jb2x9Oi8vJHtzb2NrZXRIb3N0fWAsICd2aXRlLWhtcicpXG5jb25zdCBiYXNlID0gX19CQVNFX18gfHwgJy8nXG5cbmZ1bmN0aW9uIHdhcm5GYWlsZWRGZXRjaChlcnI6IEVycm9yLCBwYXRoOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICBpZiAoIWVyci5tZXNzYWdlLm1hdGNoKCdmZXRjaCcpKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpXG4gIH1cbiAgY29uc29sZS5lcnJvcihcbiAgICBgW2htcl0gRmFpbGVkIHRvIHJlbG9hZCAke3BhdGh9LiBgICtcbiAgICAgIGBUaGlzIGNvdWxkIGJlIGR1ZSB0byBzeW50YXggZXJyb3JzIG9yIGltcG9ydGluZyBub24tZXhpc3RlbnQgYCArXG4gICAgICBgbW9kdWxlcy4gKHNlZSBlcnJvcnMgYWJvdmUpYFxuICApXG59XG5cbi8vIExpc3RlbiBmb3IgbWVzc2FnZXNcbnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKHsgZGF0YSB9KSA9PiB7XG4gIGhhbmRsZU1lc3NhZ2UoSlNPTi5wYXJzZShkYXRhKSlcbn0pXG5cbmxldCBpc0ZpcnN0VXBkYXRlID0gdHJ1ZVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKHBheWxvYWQ6IEhNUlBheWxvYWQpIHtcbiAgc3dpdGNoIChwYXlsb2FkLnR5cGUpIHtcbiAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgY29uc29sZS5sb2coYFt2aXRlXSBjb25uZWN0ZWQuYClcbiAgICAgIC8vIHByb3h5KG5naW54LCBkb2NrZXIpIGhtciB3cyBtYXliZSBjYXVzZWQgdGltZW91dCxcbiAgICAgIC8vIHNvIHNlbmQgcGluZyBwYWNrYWdlIGxldCB3cyBrZWVwIGFsaXZlLlxuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gc29ja2V0LnNlbmQoJ3BpbmcnKSwgX19ITVJfVElNRU9VVF9fKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgbm90aWZ5TGlzdGVuZXJzKCd2aXRlOmJlZm9yZVVwZGF0ZScsIHBheWxvYWQpXG4gICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgYW5kIHRoZXJlJ3MgYWxyZWFkeSBhbiBlcnJvciBvdmVybGF5LCBpdFxuICAgICAgLy8gbWVhbnMgdGhlIHBhZ2Ugb3BlbmVkIHdpdGggZXhpc3Rpbmcgc2VydmVyIGNvbXBpbGUgZXJyb3IgYW5kIHRoZSB3aG9sZVxuICAgICAgLy8gbW9kdWxlIHNjcmlwdCBmYWlsZWQgdG8gbG9hZCAoc2luY2Ugb25lIG9mIHRoZSBuZXN0ZWQgaW1wb3J0cyBpcyA1MDApLlxuICAgICAgLy8gaW4gdGhpcyBjYXNlIGEgbm9ybWFsIHVwZGF0ZSB3b24ndCB3b3JrIGFuZCBhIGZ1bGwgcmVsb2FkIGlzIG5lZWRlZC5cbiAgICAgIGlmIChpc0ZpcnN0VXBkYXRlICYmIGhhc0Vycm9yT3ZlcmxheSgpKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyRXJyb3JPdmVybGF5KClcbiAgICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlXG4gICAgICB9XG4gICAgICBwYXlsb2FkLnVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlKSA9PiB7XG4gICAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gJ2pzLXVwZGF0ZScpIHtcbiAgICAgICAgICBxdWV1ZVVwZGF0ZShmZXRjaFVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNzcy11cGRhdGVcbiAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgc2VudCB3aGVuIGEgY3NzIGZpbGUgcmVmZXJlbmNlZCB3aXRoIDxsaW5rPiBpcyB1cGRhdGVkXG4gICAgICAgICAgbGV0IHsgcGF0aCwgdGltZXN0YW1wIH0gPSB1cGRhdGVcbiAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXD8uKi8sICcnKVxuICAgICAgICAgIC8vIGNhbid0IHVzZSBxdWVyeVNlbGVjdG9yIHdpdGggYFtocmVmKj1dYCBoZXJlIHNpbmNlIHRoZSBsaW5rIG1heSBiZVxuICAgICAgICAgIC8vIHVzaW5nIHJlbGF0aXZlIHBhdGhzIHNvIHdlIG5lZWQgdG8gdXNlIGxpbmsuaHJlZiB0byBncmFiIHRoZSBmdWxsXG4gICAgICAgICAgLy8gVVJMIGZvciB0aGUgaW5jbHVkZSBjaGVjay5cbiAgICAgICAgICBjb25zdCBlbCA9IChcbiAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoXG4gICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYGxpbmtgKVxuICAgICAgICAgICAgKSBhcyBIVE1MTGlua0VsZW1lbnRbXVxuICAgICAgICAgICkuZmluZCgoZSkgPT4gZS5ocmVmLmluY2x1ZGVzKHBhdGgpKVxuICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgY29uc3QgbmV3UGF0aCA9IGAke2Jhc2V9JHtwYXRoLnNsaWNlKDEpfSR7XG4gICAgICAgICAgICAgIHBhdGguaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/J1xuICAgICAgICAgICAgfXQ9JHt0aW1lc3RhbXB9YFxuICAgICAgICAgICAgZWwuaHJlZiA9IG5ldyBVUkwobmV3UGF0aCwgZWwuaHJlZikuaHJlZlxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmxvZyhgW3ZpdGVdIGNzcyBob3QgdXBkYXRlZDogJHtwYXRofWApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2N1c3RvbSc6IHtcbiAgICAgIG5vdGlmeUxpc3RlbmVycyhwYXlsb2FkLmV2ZW50IGFzIEN1c3RvbUV2ZW50TmFtZTxhbnk+LCBwYXlsb2FkLmRhdGEpXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdmdWxsLXJlbG9hZCc6XG4gICAgICBub3RpZnlMaXN0ZW5lcnMoJ3ZpdGU6YmVmb3JlRnVsbFJlbG9hZCcsIHBheWxvYWQpXG4gICAgICBpZiAocGF5bG9hZC5wYXRoICYmIHBheWxvYWQucGF0aC5lbmRzV2l0aCgnLmh0bWwnKSkge1xuICAgICAgICAvLyBpZiBodG1sIGZpbGUgaXMgZWRpdGVkLCBvbmx5IHJlbG9hZCB0aGUgcGFnZSBpZiB0aGUgYnJvd3NlciBpc1xuICAgICAgICAvLyBjdXJyZW50bHkgb24gdGhhdCBwYWdlLlxuICAgICAgICBjb25zdCBwYWdlUGF0aCA9IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIGNvbnN0IHBheWxvYWRQYXRoID0gYmFzZSArIHBheWxvYWQucGF0aC5zbGljZSgxKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcGFnZVBhdGggPT09IHBheWxvYWRQYXRoIHx8XG4gICAgICAgICAgKHBhZ2VQYXRoLmVuZHNXaXRoKCcvJykgJiYgcGFnZVBhdGggKyAnaW5kZXguaHRtbCcgPT09IHBheWxvYWRQYXRoKVxuICAgICAgICApIHtcbiAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHJ1bmUnOlxuICAgICAgbm90aWZ5TGlzdGVuZXJzKCd2aXRlOmJlZm9yZVBydW5lJywgcGF5bG9hZClcbiAgICAgIC8vIEFmdGVyIGFuIEhNUiB1cGRhdGUsIHNvbWUgbW9kdWxlcyBhcmUgbm8gbG9uZ2VyIGltcG9ydGVkIG9uIHRoZSBwYWdlXG4gICAgICAvLyBidXQgdGhleSBtYXkgaGF2ZSBsZWZ0IGJlaGluZCBzaWRlIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlIGNsZWFuZWQgdXBcbiAgICAgIC8vICguZS5nIHN0eWxlIGluamVjdGlvbnMpXG4gICAgICAvLyBUT0RPIFRyaWdnZXIgdGhlaXIgZGlzcG9zZSBjYWxsYmFja3MuXG4gICAgICBwYXlsb2FkLnBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgZm4gPSBwcnVuZU1hcC5nZXQocGF0aClcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgZm4oZGF0YU1hcC5nZXQocGF0aCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Vycm9yJzoge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKCd2aXRlOmVycm9yJywgcGF5bG9hZClcbiAgICAgIGNvbnN0IGVyciA9IHBheWxvYWQuZXJyXG4gICAgICBpZiAoZW5hYmxlT3ZlcmxheSkge1xuICAgICAgICBjcmVhdGVFcnJvck92ZXJsYXkoZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgW3ZpdGVdIEludGVybmFsIFNlcnZlciBFcnJvclxcbiR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBjaGVjazogbmV2ZXIgPSBwYXlsb2FkXG4gICAgICByZXR1cm4gY2hlY2tcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKFxuICBldmVudDogJ3ZpdGU6YmVmb3JlVXBkYXRlJyxcbiAgcGF5bG9hZDogVXBkYXRlUGF5bG9hZFxuKTogdm9pZFxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGV2ZW50OiAndml0ZTpiZWZvcmVQcnVuZScsIHBheWxvYWQ6IFBydW5lUGF5bG9hZCk6IHZvaWRcbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycyhcbiAgZXZlbnQ6ICd2aXRlOmJlZm9yZUZ1bGxSZWxvYWQnLFxuICBwYXlsb2FkOiBGdWxsUmVsb2FkUGF5bG9hZFxuKTogdm9pZFxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGV2ZW50OiAndml0ZTplcnJvcicsIHBheWxvYWQ6IEVycm9yUGF5bG9hZCk6IHZvaWRcbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVyczxUIGV4dGVuZHMgc3RyaW5nPihcbiAgZXZlbnQ6IEN1c3RvbUV2ZW50TmFtZTxUPixcbiAgZGF0YTogYW55XG4pOiB2b2lkXG5mdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoZXZlbnQ6IHN0cmluZywgZGF0YTogYW55KTogdm9pZCB7XG4gIGNvbnN0IGNicyA9IGN1c3RvbUxpc3RlbmVyc01hcC5nZXQoZXZlbnQpXG4gIGlmIChjYnMpIHtcbiAgICBjYnMuZm9yRWFjaCgoY2IpID0+IGNiKGRhdGEpKVxuICB9XG59XG5cbmNvbnN0IGVuYWJsZU92ZXJsYXkgPSBfX0hNUl9FTkFCTEVfT1ZFUkxBWV9fXG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yT3ZlcmxheShlcnI6IEVycm9yUGF5bG9hZFsnZXJyJ10pIHtcbiAgaWYgKCFlbmFibGVPdmVybGF5KSByZXR1cm5cbiAgY2xlYXJFcnJvck92ZXJsYXkoKVxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5ldyBFcnJvck92ZXJsYXkoZXJyKSlcbn1cblxuZnVuY3Rpb24gY2xlYXJFcnJvck92ZXJsYXkoKSB7XG4gIGRvY3VtZW50XG4gICAgLnF1ZXJ5U2VsZWN0b3JBbGwob3ZlcmxheUlkKVxuICAgIC5mb3JFYWNoKChuKSA9PiAobiBhcyBFcnJvck92ZXJsYXkpLmNsb3NlKCkpXG59XG5cbmZ1bmN0aW9uIGhhc0Vycm9yT3ZlcmxheSgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob3ZlcmxheUlkKS5sZW5ndGhcbn1cblxubGV0IHBlbmRpbmcgPSBmYWxzZVxubGV0IHF1ZXVlZDogUHJvbWlzZTwoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ+W10gPSBbXVxuXG4vKipcbiAqIGJ1ZmZlciBtdWx0aXBsZSBob3QgdXBkYXRlcyB0cmlnZ2VyZWQgYnkgdGhlIHNhbWUgc3JjIGNoYW5nZVxuICogc28gdGhhdCB0aGV5IGFyZSBpbnZva2VkIGluIHRoZSBzYW1lIG9yZGVyIHRoZXkgd2VyZSBzZW50LlxuICogKG90aGVyd2lzZSB0aGUgb3JkZXIgbWF5IGJlIGluY29uc2lzdGVudCBiZWNhdXNlIG9mIHRoZSBodHRwIHJlcXVlc3Qgcm91bmQgdHJpcClcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcXVldWVVcGRhdGUocDogUHJvbWlzZTwoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ+KSB7XG4gIHF1ZXVlZC5wdXNoKHApXG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlXG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKClcbiAgICBwZW5kaW5nID0gZmFsc2VcbiAgICBjb25zdCBsb2FkaW5nID0gWy4uLnF1ZXVlZF1cbiAgICBxdWV1ZWQgPSBbXVxuICAgIDsoYXdhaXQgUHJvbWlzZS5hbGwobG9hZGluZykpLmZvckVhY2goKGZuKSA9PiBmbiAmJiBmbigpKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JTdWNjZXNzZnVsUGluZyhtcyA9IDEwMDApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmZXRjaChgJHtiYXNlfV9fdml0ZV9waW5nYClcbiAgICAgIGJyZWFrXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKVxuICAgIH1cbiAgfVxufVxuXG4vLyBwaW5nIHNlcnZlclxuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgYXN5bmMgKHsgd2FzQ2xlYW4gfSkgPT4ge1xuICBpZiAod2FzQ2xlYW4pIHJldHVyblxuICBjb25zb2xlLmxvZyhgW3ZpdGVdIHNlcnZlciBjb25uZWN0aW9uIGxvc3QuIHBvbGxpbmcgZm9yIHJlc3RhcnQuLi5gKVxuICBhd2FpdCB3YWl0Rm9yU3VjY2Vzc2Z1bFBpbmcoKVxuICBsb2NhdGlvbi5yZWxvYWQoKVxufSlcblxuLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb25zdHJ1Y3Qtc3R5bGVzaGVldHNcbmNvbnN0IHN1cHBvcnRzQ29uc3RydWN0ZWRTaGVldCA9ICgoKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gbmV3IENTU1N0eWxlU2hlZXQoKVxuICAgIC8vIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBmYWxzZVxufSkoKVxuXG5jb25zdCBzaGVldHNNYXAgPSBuZXcgTWFwKClcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGlkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQge1xuICBsZXQgc3R5bGUgPSBzaGVldHNNYXAuZ2V0KGlkKVxuICBpZiAoc3VwcG9ydHNDb25zdHJ1Y3RlZFNoZWV0ICYmICFjb250ZW50LmluY2x1ZGVzKCdAaW1wb3J0JykpIHtcbiAgICBpZiAoc3R5bGUgJiYgIShzdHlsZSBpbnN0YW5jZW9mIENTU1N0eWxlU2hlZXQpKSB7XG4gICAgICByZW1vdmVTdHlsZShpZClcbiAgICAgIHN0eWxlID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKCFzdHlsZSkge1xuICAgICAgc3R5bGUgPSBuZXcgQ1NTU3R5bGVTaGVldCgpXG4gICAgICBzdHlsZS5yZXBsYWNlU3luYyhjb250ZW50KVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzID0gWy4uLmRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cywgc3R5bGVdXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLnJlcGxhY2VTeW5jKGNvbnRlbnQpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdHlsZSAmJiAhKHN0eWxlIGluc3RhbmNlb2YgSFRNTFN0eWxlRWxlbWVudCkpIHtcbiAgICAgIHJlbW92ZVN0eWxlKGlkKVxuICAgICAgc3R5bGUgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoIXN0eWxlKSB7XG4gICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpXG4gICAgICBzdHlsZS5pbm5lckhUTUwgPSBjb250ZW50XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5pbm5lckhUTUwgPSBjb250ZW50XG4gICAgfVxuICB9XG4gIHNoZWV0c01hcC5zZXQoaWQsIHN0eWxlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlU3R5bGUoaWQ6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBzdHlsZSA9IHNoZWV0c01hcC5nZXQoaWQpXG4gIGlmIChzdHlsZSkge1xuICAgIGlmIChzdHlsZSBpbnN0YW5jZW9mIENTU1N0eWxlU2hlZXQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IGluZGV4ID0gZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLmluZGV4T2Yoc3R5bGUpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMgPSBkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMuZmlsdGVyKFxuICAgICAgICAoczogQ1NTU3R5bGVTaGVldCkgPT4gcyAhPT0gc3R5bGVcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSlcbiAgICB9XG4gICAgc2hlZXRzTWFwLmRlbGV0ZShpZClcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFVwZGF0ZSh7IHBhdGgsIGFjY2VwdGVkUGF0aCwgdGltZXN0YW1wIH06IFVwZGF0ZSkge1xuICBjb25zdCBtb2QgPSBob3RNb2R1bGVzTWFwLmdldChwYXRoKVxuICBpZiAoIW1vZCkge1xuICAgIC8vIEluIGEgY29kZS1zcGxpdHRpbmcgcHJvamVjdCxcbiAgICAvLyBpdCBpcyBjb21tb24gdGhhdCB0aGUgaG90LXVwZGF0aW5nIG1vZHVsZSBpcyBub3QgbG9hZGVkIHlldC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzcyMVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbW9kdWxlTWFwID0gbmV3IE1hcCgpXG4gIGNvbnN0IGlzU2VsZlVwZGF0ZSA9IHBhdGggPT09IGFjY2VwdGVkUGF0aFxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSBvbmx5IGltcG9ydCBlYWNoIGRlcCBvbmNlXG4gIGNvbnN0IG1vZHVsZXNUb1VwZGF0ZSA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGlmIChpc1NlbGZVcGRhdGUpIHtcbiAgICAvLyBzZWxmIHVwZGF0ZSAtIG9ubHkgdXBkYXRlIHNlbGZcbiAgICBtb2R1bGVzVG9VcGRhdGUuYWRkKHBhdGgpXG4gIH0gZWxzZSB7XG4gICAgLy8gZGVwIHVwZGF0ZVxuICAgIGZvciAoY29uc3QgeyBkZXBzIH0gb2YgbW9kLmNhbGxiYWNrcykge1xuICAgICAgZGVwcy5mb3JFYWNoKChkZXApID0+IHtcbiAgICAgICAgaWYgKGFjY2VwdGVkUGF0aCA9PT0gZGVwKSB7XG4gICAgICAgICAgbW9kdWxlc1RvVXBkYXRlLmFkZChkZXApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBxdWFsaWZpZWQgY2FsbGJhY2tzIGJlZm9yZSB3ZSByZS1pbXBvcnQgdGhlIG1vZHVsZXNcbiAgY29uc3QgcXVhbGlmaWVkQ2FsbGJhY2tzID0gbW9kLmNhbGxiYWNrcy5maWx0ZXIoKHsgZGVwcyB9KSA9PiB7XG4gICAgcmV0dXJuIGRlcHMuc29tZSgoZGVwKSA9PiBtb2R1bGVzVG9VcGRhdGUuaGFzKGRlcCkpXG4gIH0pXG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgQXJyYXkuZnJvbShtb2R1bGVzVG9VcGRhdGUpLm1hcChhc3luYyAoZGVwKSA9PiB7XG4gICAgICBjb25zdCBkaXNwb3NlciA9IGRpc3Bvc2VNYXAuZ2V0KGRlcClcbiAgICAgIGlmIChkaXNwb3NlcikgYXdhaXQgZGlzcG9zZXIoZGF0YU1hcC5nZXQoZGVwKSlcbiAgICAgIGNvbnN0IFtwYXRoLCBxdWVyeV0gPSBkZXAuc3BsaXQoYD9gKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3TW9kID0gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgICAgICAgIGJhc2UgK1xuICAgICAgICAgICAgcGF0aC5zbGljZSgxKSArXG4gICAgICAgICAgICBgP2ltcG9ydCZ0PSR7dGltZXN0YW1wfSR7cXVlcnkgPyBgJiR7cXVlcnl9YCA6ICcnfWBcbiAgICAgICAgKVxuICAgICAgICBtb2R1bGVNYXAuc2V0KGRlcCwgbmV3TW9kKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXJuRmFpbGVkRmV0Y2goZSwgZGVwKVxuICAgICAgfVxuICAgIH0pXG4gIClcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgeyBkZXBzLCBmbiB9IG9mIHF1YWxpZmllZENhbGxiYWNrcykge1xuICAgICAgZm4oZGVwcy5tYXAoKGRlcCkgPT4gbW9kdWxlTWFwLmdldChkZXApKSlcbiAgICB9XG4gICAgY29uc3QgbG9nZ2VkUGF0aCA9IGlzU2VsZlVwZGF0ZSA/IHBhdGggOiBgJHthY2NlcHRlZFBhdGh9IHZpYSAke3BhdGh9YFxuICAgIGNvbnNvbGUubG9nKGBbdml0ZV0gaG90IHVwZGF0ZWQ6ICR7bG9nZ2VkUGF0aH1gKVxuICB9XG59XG5cbmludGVyZmFjZSBIb3RNb2R1bGUge1xuICBpZDogc3RyaW5nXG4gIGNhbGxiYWNrczogSG90Q2FsbGJhY2tbXVxufVxuXG5pbnRlcmZhY2UgSG90Q2FsbGJhY2sge1xuICAvLyB0aGUgZGVwZW5kZW5jaWVzIG11c3QgYmUgZmV0Y2hhYmxlIHBhdGhzXG4gIGRlcHM6IHN0cmluZ1tdXG4gIGZuOiAobW9kdWxlczogb2JqZWN0W10pID0+IHZvaWRcbn1cblxuY29uc3QgaG90TW9kdWxlc01hcCA9IG5ldyBNYXA8c3RyaW5nLCBIb3RNb2R1bGU+KClcbmNvbnN0IGRpc3Bvc2VNYXAgPSBuZXcgTWFwPHN0cmluZywgKGRhdGE6IGFueSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4+KClcbmNvbnN0IHBydW5lTWFwID0gbmV3IE1hcDxzdHJpbmcsIChkYXRhOiBhbnkpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+PigpXG5jb25zdCBkYXRhTWFwID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKVxuY29uc3QgY3VzdG9tTGlzdGVuZXJzTWFwID0gbmV3IE1hcDxzdHJpbmcsICgoZGF0YTogYW55KSA9PiB2b2lkKVtdPigpXG5jb25zdCBjdHhUb0xpc3RlbmVyc01hcCA9IG5ldyBNYXA8XG4gIHN0cmluZyxcbiAgTWFwPHN0cmluZywgKChkYXRhOiBhbnkpID0+IHZvaWQpW10+XG4+KClcblxuLy8gSnVzdCBpbmZlciB0aGUgcmV0dXJuIHR5cGUgZm9yIG5vd1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmV4cG9ydCBjb25zdCBjcmVhdGVIb3RDb250ZXh0ID0gKG93bmVyUGF0aDogc3RyaW5nKSA9PiB7XG4gIGlmICghZGF0YU1hcC5oYXMob3duZXJQYXRoKSkge1xuICAgIGRhdGFNYXAuc2V0KG93bmVyUGF0aCwge30pXG4gIH1cblxuICAvLyB3aGVuIGEgZmlsZSBpcyBob3QgdXBkYXRlZCwgYSBuZXcgY29udGV4dCBpcyBjcmVhdGVkXG4gIC8vIGNsZWFyIGl0cyBzdGFsZSBjYWxsYmFja3NcbiAgY29uc3QgbW9kID0gaG90TW9kdWxlc01hcC5nZXQob3duZXJQYXRoKVxuICBpZiAobW9kKSB7XG4gICAgbW9kLmNhbGxiYWNrcyA9IFtdXG4gIH1cblxuICAvLyBjbGVhciBzdGFsZSBjdXN0b20gZXZlbnQgbGlzdGVuZXJzXG4gIGNvbnN0IHN0YWxlTGlzdGVuZXJzID0gY3R4VG9MaXN0ZW5lcnNNYXAuZ2V0KG93bmVyUGF0aClcbiAgaWYgKHN0YWxlTGlzdGVuZXJzKSB7XG4gICAgZm9yIChjb25zdCBbZXZlbnQsIHN0YWxlRm5zXSBvZiBzdGFsZUxpc3RlbmVycykge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gY3VzdG9tTGlzdGVuZXJzTWFwLmdldChldmVudClcbiAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgY3VzdG9tTGlzdGVuZXJzTWFwLnNldChcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBsaXN0ZW5lcnMuZmlsdGVyKChsKSA9PiAhc3RhbGVGbnMuaW5jbHVkZXMobCkpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdMaXN0ZW5lcnMgPSBuZXcgTWFwKClcbiAgY3R4VG9MaXN0ZW5lcnNNYXAuc2V0KG93bmVyUGF0aCwgbmV3TGlzdGVuZXJzKVxuXG4gIGZ1bmN0aW9uIGFjY2VwdERlcHMoZGVwczogc3RyaW5nW10sIGNhbGxiYWNrOiBIb3RDYWxsYmFja1snZm4nXSA9ICgpID0+IHt9KSB7XG4gICAgY29uc3QgbW9kOiBIb3RNb2R1bGUgPSBob3RNb2R1bGVzTWFwLmdldChvd25lclBhdGgpIHx8IHtcbiAgICAgIGlkOiBvd25lclBhdGgsXG4gICAgICBjYWxsYmFja3M6IFtdXG4gICAgfVxuICAgIG1vZC5jYWxsYmFja3MucHVzaCh7XG4gICAgICBkZXBzLFxuICAgICAgZm46IGNhbGxiYWNrXG4gICAgfSlcbiAgICBob3RNb2R1bGVzTWFwLnNldChvd25lclBhdGgsIG1vZClcbiAgfVxuXG4gIGNvbnN0IGhvdCA9IHtcbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgIHJldHVybiBkYXRhTWFwLmdldChvd25lclBhdGgpXG4gICAgfSxcblxuICAgIGFjY2VwdChkZXBzOiBhbnksIGNhbGxiYWNrPzogYW55KSB7XG4gICAgICBpZiAodHlwZW9mIGRlcHMgPT09ICdmdW5jdGlvbicgfHwgIWRlcHMpIHtcbiAgICAgICAgLy8gc2VsZi1hY2NlcHQ6IGhvdC5hY2NlcHQoKCkgPT4ge30pXG4gICAgICAgIGFjY2VwdERlcHMoW293bmVyUGF0aF0sIChbbW9kXSkgPT4gZGVwcyAmJiBkZXBzKG1vZCkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBleHBsaWNpdCBkZXBzXG4gICAgICAgIGFjY2VwdERlcHMoW2RlcHNdLCAoW21vZF0pID0+IGNhbGxiYWNrICYmIGNhbGxiYWNrKG1vZCkpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgYWNjZXB0RGVwcyhkZXBzLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBob3QuYWNjZXB0KCkgdXNhZ2UuYClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWNjZXB0RGVwcygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGhvdC5hY2NlcHREZXBzKCkgaXMgZGVwcmVjYXRlZC4gYCArXG4gICAgICAgICAgYFVzZSBob3QuYWNjZXB0KCkgd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUgaW5zdGVhZC5gXG4gICAgICApXG4gICAgfSxcblxuICAgIGRpc3Bvc2UoY2I6IChkYXRhOiBhbnkpID0+IHZvaWQpIHtcbiAgICAgIGRpc3Bvc2VNYXAuc2V0KG93bmVyUGF0aCwgY2IpXG4gICAgfSxcblxuICAgIHBydW5lKGNiOiAoZGF0YTogYW55KSA9PiB2b2lkKSB7XG4gICAgICBwcnVuZU1hcC5zZXQob3duZXJQYXRoLCBjYilcbiAgICB9LFxuXG4gICAgLy8gVE9ET1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICBkZWNsaW5lKCkge30sXG5cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgLy8gVE9ETyBzaG91bGQgdGVsbCB0aGUgc2VydmVyIHRvIHJlLXBlcmZvcm0gaG1yIHByb3BhZ2F0aW9uXG4gICAgICAvLyBmcm9tIHRoaXMgbW9kdWxlIGFzIHJvb3RcbiAgICAgIGxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfSxcblxuICAgIC8vIGN1c3RvbSBldmVudHNcbiAgICBvbjogKGV2ZW50OiBzdHJpbmcsIGNiOiAoZGF0YTogYW55KSA9PiB2b2lkKSA9PiB7XG4gICAgICBjb25zdCBhZGRUb01hcCA9IChtYXA6IE1hcDxzdHJpbmcsIGFueVtdPikgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IG1hcC5nZXQoZXZlbnQpIHx8IFtdXG4gICAgICAgIGV4aXN0aW5nLnB1c2goY2IpXG4gICAgICAgIG1hcC5zZXQoZXZlbnQsIGV4aXN0aW5nKVxuICAgICAgfVxuICAgICAgYWRkVG9NYXAoY3VzdG9tTGlzdGVuZXJzTWFwKVxuICAgICAgYWRkVG9NYXAobmV3TGlzdGVuZXJzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBob3Rcbn1cblxuLyoqXG4gKiB1cmxzIGhlcmUgYXJlIGR5bmFtaWMgaW1wb3J0KCkgdXJscyB0aGF0IGNvdWxkbid0IGJlIHN0YXRpY2FsbHkgYW5hbHl6ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdFF1ZXJ5KHVybDogc3RyaW5nLCBxdWVyeVRvSW5qZWN0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBza2lwIHVybHMgdGhhdCB3b24ndCBiZSBoYW5kbGVkIGJ5IHZpdGVcbiAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnLicpICYmICF1cmwuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgcmV0dXJuIHVybFxuICB9XG5cbiAgLy8gY2FuJ3QgdXNlIHBhdGhuYW1lIGZyb20gVVJMIHNpbmNlIGl0IG1heSBiZSByZWxhdGl2ZSBsaWtlIC4uL1xuICBjb25zdCBwYXRobmFtZSA9IHVybC5yZXBsYWNlKC8jLiokLywgJycpLnJlcGxhY2UoL1xcPy4qJC8sICcnKVxuICBjb25zdCB7IHNlYXJjaCwgaGFzaCB9ID0gbmV3IFVSTCh1cmwsICdodHRwOi8vdml0ZWpzLmRldicpXG5cbiAgcmV0dXJuIGAke3BhdGhuYW1lfT8ke3F1ZXJ5VG9JbmplY3R9JHtzZWFyY2ggPyBgJmAgKyBzZWFyY2guc2xpY2UoMSkgOiAnJ30ke1xuICAgIGhhc2ggfHwgJydcbiAgfWBcbn1cbiJdfQ==